; 2.53
; (a b c)
; ((george))
; ((y1 y2))
; (y1 y2)
; #f
; #f
; (red shoes blue socks)
(print-as-expression #f)
(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))

;2.54
(define (equal? a b)
  (cond ;((and (symbol? a) (symbol? b)) (eq? a b))
        ((and (pair? a) (pair? b))
         (and
           (equal? (car a) (car b))
           (equal? (cdr a) (cdr b))))
        (else (eq? a b))))
(equal? '(this is a list) '(this is a list))
(equal? '(this (is a) list) '(this (is a) list))
(equal? '(this is a list) '(this (is a) list))

;2.56
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (=number? exp num)
    (and (number? exp) (= exp num)))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        ((not (product? m2)) (list '* m1 m2))
        (else
          (let ((rest
(make-product 'x '(* y z))

  (cond ((=number? m1 0) 0)
        ((null? m2) m1)
        (else
          (let ((rest (make-product  (car m2) (cdr m2))))
            (cond ((=number? rest 0) 0)
                  ((=number? rest 1) m1)
                  ((=number? m1 1) rest)
                  ((and (number? m1) (number? rest)) (* m1 rest))
                  ((number? rest) (list '* m1 rest))
                  (else (append (list '* m1) (cdr rest))))))))

(define (sum? x)
    (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (make-product (caddr s) (cdddr s)))
(define (product? x)
    (and (pair? x) (eq? (car x) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand p) (make-product (caddr p) (cdddr p))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        ((exponentiation? exp)
         (let ((b (base exp))
               (e (exponent exp)))
           (make-product
             e
             (make-exponentiation b (- e 1)))))
        (else
          (error "unknown expression type -- DERIV" exp))))
(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)
(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))
(define (base x) (cadr x))
(define (exponent x) (caddr x))
(define (make-exponentiation b x)
  (cond ((=number? x 0) 1)
        ((=number? x 1) b)
        (else (list '** b x))))
(deriv '(* x y (+ x 3)) 'x)
