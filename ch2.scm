(define (gcd a b)
  (if (= b 0)
    a
    (gcd b (remainder a b))))
(define (make-rat n d)
  (let ((g (abs (gcd n d)))
        (n (if (< d 0) (- n) n))
        (d (abs d)))
    (cons (/ n g) (/ d g)))))
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))
(define one-half (make-rat 1 (- 2)))
(print-rat one-half)
(define one-third (make-rat 1 3))
(print-rat (add-rat one-half one-third))
(print-rat (mul-rat one-half one-third))
(print-rat (add-rat one-third one-third))

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (make-segment start end)
  (cons start end))
(define (start-segment segment)
  (car segment))
(define (end-segment segment)
  (cdr segment))
(define (make-point x y)
  (cons x y))
(define (x-point point)
  (car point))
(define (y-point point)
  (cdr point))
(define (average x y)
  (/ (+ x y) 2))
(define (midpoint-segment segment)
  (let ((start (start-segment segment))
        (end (end-segment segment)))
    (let ((x1 (x-point start))
          (x2 (x-point end))
          (y1 (y-point start))
          (y2 (y-point end)))
      (make-point (average x1 x2) (average y1 y2)))))
(define seg (make-segment (make-point 0 0) (make-point 1 10)))
(print-point (midpoint-segment seg))
(define (make-rect bl tr)
  (cons bl tr))
(define (len rect)
  (let ((x1 (x-point (car rect)))
        (x2 (x-point (cdr rect))))
    (- x2 x1)))
(define (width rect)
  (let ((y1 (y-point (car rect)))
        (y2 (y-point (cdr rect))))
    (- y2 y1)))
(define (area rect)
  (* (len rect) (width rect)))
(define (perimeter rect)
  (* 2 (+ (len rect) (width rect))))
(define testrect (make-rect (make-point 0 0) (make-point 3 2)))
(area testrect)
(perimeter testrect)

;2.4 (define (cdr z) (z (lambda (p q) q)))

(define (power? n test)
  (define (iter current)
    (cond
      ((= current test) #t)
      ((> current test) #f)
      (else (iter (* n current)))))
  (iter 1))
(define (cons a b)
  (* (expt 2 a) (expt 3 b)))
(define (car pair)
  (define (iter current count total)
    (if (or (= 0 total) (power? 3 total))
      count
      (iter (* current 2) (+ 1 count) (/ total 2))))
  (iter 1 0 pair))
(define (cdr pair)
  (define (iter current count total)
    (if (or (= 0 total) (power? 2 total))
      count
      (iter (* current 3) (+ 1 count) (/ total 3))))
  (iter 1 0 pair))
(car (cons 0 1))
(cdr (cons 1 0))

(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))
(define three (lambda (f) (lambda (x) (f (f (f x))))))
(define five (lambda (f) (lambda (x) (f (f (f (f (f x))))))))
(define (inc x) (+ 1 x))
(define (multiply a b)
  (lambda (f) (lambda (x) ((a (b f)) x))))
(define (add a b)
  (lambda (f) (lambda (x) ((a f) ((b f) x)))))
((five inc) 0)
(((add two three) inc) 0)

(define (make-interval a b) (cons a b))
(define (lower-bound interval) (car interval))
(define (upper-bound interval) (cdr interval))
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
(define (div-interval x y)
  (if (or (spans-zero? x) (spans-zero? y))
    (error "Cannot divide by an interval that spans 0")
    (mul-interval x 
                  (make-interval (/ 1.0 (upper-bound y))
                                 (/ 1.0 (lower-bound y))))))
(define (spans-zero? interval)
  (and (<= (lower-bound interval) 0)
       (>= (upper-bound interval) 0)))
(define (sub-interval x y)
  (make-interval (- (lower-bound x) (lower-bound y))
                 (- (upper-bound x) (upper-bound y))))
(define (make-center-width c w)
    (make-interval (- c w) (+ c w)))
(define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))
(define (make-center-percent c p)
  (make-center-width c (* c (/ p 100))))
(define (percent interval)
  (let ((c (center interval))
        (w (width interval)))
    (* 100 (/ w c))))
